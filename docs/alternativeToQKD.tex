\title{A commercial alternative to QKD: filling USB sticks and hard disks with random bits}

\documentclass{paper}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{geometry}
\geometry{
	a4paper,	
	margin=20mm
}

\usepackage{hyperref}

\begin{document}
	\maketitle
	\section{Introduction}
		QKD (Quantum Key Cryptography) provides complete security but is limited by its expense and limited range. QKD also requires the initial distribution of small keys to start the system running, this is usually done by physical means. This begs the question, is it more commercially viable to distribute disks filled with large amounts of random bits for use in an cryptographic system?\\
		This approach would allow symmetric key cryptography in the same way it is facilitated by QKD, but also allows for a more flexible system as the vast number of bits are immediately available, allowing a one time pad to be used.\\
%TODO
	\subsection{Threat Model}
%TODO
	
	
	\section{Randomness Sources}
		Good quality randomness sources are required when filling a disk with random bits. This though has to be balanced with sources which can provide a good throughput rate so that filling a large disk with random bits is feasible.\\ 
	
		\subsection{Intel RDRAND}
			\subsubsection{Throughput}
				Intel RDRAND has an incredibly high maximum theoretical throughput at 800 MB/sec. (Note though that a single thread will see a throughput of 70 to 200MB/sec).\footnote{\url{https://software.intel.com/sites/default/files/managed/4d/91/DRNG_Software_Implementation_Guide_2.0.pdf}} \\
				Benchmarks show that we could fill a 1TB disk in 4 Hours, 20 Minutes and 56 Seconds using RDRAND at throughput rates of:\\
				100MB in 1.571749s = 63.62 MB/s\\
				100MB in 1.563457s = 63.96 MB/s\\
				100MB in 1.561578s = 64.04 MB/s\\
				Yielding a  throughput of 63.87 MB/s\\
				This throughput rate is more than suitable for our needs of filling a disk.
			\subsubsection{Quality}
				Intel's TRNG has been analysed by Cryptography Research, Inc.\footnote{Jun, B. and Kocher, P.``The Intel Random Number Generator'' Cryptography Research, Inc., April 1999} and was found to be suitable for cryptographic purposes.\\
				Although found to be suitible for cryptographic purposes, there is much speculation about possible backdoors and trojans into Intels RDRAND system. It has been found that it is possible to insert a Trojan into the Intel CPU without detection.\footnote{Becker, Georg T., et al.``Stealthy dopant-level hardware trojans.'' International Workshop on Cryptographic Hardware and Embedded Systems. Springer Berlin Heidelberg, 2013}\\
				Though Intel's David Johnston states ``I’ve examined my own RNG with electron microscopes and picoprobes. So I and a number of test engineers know full well that the design hasn’t been subverted.''\footnote{\url{https://plus.google.com/+TheodoreTso/posts/SDcoemc9V3J}}\\
				Due to the risk of an undetected hardware trojan it's preferable that the Intel TRNG is not the sole source of entropy in the system.
				
		\subsection{ID Quantique Quantis}
		ID Quantique produce hardware random number generators which use Quantum Physics to produce a stream of true random numbers.
			\subsubsection{Throughput}
				Each Quantis module is capable of providing a throughput of 4mb/s\footnote{\url{http://marketing.idquantique.com/acton/attachment/11868/f-004b/1/-/-/-/-/Quantum\%20RNG\%20White\%20Paper.pdf}}.\\
				This equates to generating 1GB of random bits in 34 Minutes and 08 Seconds, which would mean a 1TB disk in 582 Hours, 32 Minutes and 32 Seconds. This is over 24 days and therefore is completely inappropriate for use as a direct source.\\
			
		\subsection{Linux /dev/random}
		The linux kernel aims to provide a CSPRNG with its \texttt{/dev/random} device.
			\subsubsection{Throughput}
				The throughput of \texttt{/dev/random} is highly variable due to it gathering entropy from the usage of the machine. Completed benchmarks though showed the following results:\\	
				1MB = 37.0049s, 27.0 kB/s\\
				1MB = 37.7160s, 26.5 kB/s\\
				1MB = 38.2632s, 26.1 kB/s\\
				Yielding a mean throughput of 26.5kB/s\\
				
				This incredibly low throughput would result in 1GB being generated in 10 Hours, 59 Minutes and 28 Second. Therefore it is also useless to the system as a direct source of random bits.\\
			\subsubsection{Quality}
				There is little analysis into the Linux implementation of  \texttt{/dev/random} and its PRNG as a whole. It is though generally accepted that it is an appropriate way to source good quality random bits.\\
			
		\subsection{AES CTR as a CSPRNG}
			AES can be used in CTR mode as a CSPRNG.\\
			\subsubsection{Throughput}
				Using AES-NI the throughput of AES-CTR can be incredibly fast.\\
				Benchmarks gathered show:\\
				100 MB = 0.422515s = 236.68 MB/s\\
				100 MB = 0.398120s = 251.18 MB/s\\
				100 MB = 0.412899s = 242.19 MB/s\\
				Yielding a mean throughput of 243.35 MB/s\\
				
				This incredibly high throughput would allow us to fill a 1TB disk in 1 Hours, 11 Minutes and 48 Seconds. This makes it a perfect candidate for a source of random bits.\\
			\subsubsection{Quality}
				The quality of a AES-CTR CSPRNG is well trusted as a good source of random bits. Though this trust completely depends on a good key to seed the keystream.\\
				To make the most of the good quality but lower throughput sources described prior (Quantis \& \texttt{/dev/random}) they can be used to seed an AES-CTR keystream.\\
			
		\subsection{Chosen Source}
			Combining Intel RDRAND with an AES CSPRNG through XOR was chosen as the source of random bits in the system. This is due the speed of both sources and the potential security risk of RDRAND meaning it is preferable not to be used alone.
			\subsubsection{Statistical Testing}
			The suite of statistical tests used on the random bits generated is the DieHarder Suite.\\  
			Both of these test results show a small amount of `WEAK' results from the analysis. Detailed results:\\ 
			AES CSPRNG:\url{https://pastebin.com/raw/gcH4jXGp}\\ RDRAND:\url{https://pastebin.com/raw/diEgthVN}\\
			This can also be explained by the DieHarder manual pages which state \textit{``If you run a long test series, you will see occasional weak returns for a perfect generators because p is uniformly distributed and will appear in any finite interval from time to time.''}\footnote{\url{http://manpages.ubuntu.com/manpages/precise/man1/dieharder.1.html}}
		
		\section{System Architecture}
			\subsection{File storage}
				File system structure: \vspace{-0.75em}
				\begin{itemize}
				\setlength\itemsep{-0.3em}
				\item Disks that hold random bits are formatted in unjournalled ext4 with a block size of 4K.
				\item $n$ random bit files are stored on the disk at the root directory and named sequentially:\\
				$0.\texttt{bin}, 1.\texttt{bin}, 2.\texttt{bin}, \cdots , n.\texttt{bin}$.
				\item Random bit files are 100003840 bytes long.
				\item A state file is stored along the random bit files comprising of:\\ $\left[ \texttt{scrypt-salt}\parallel\texttt{current-file-num}\parallel\texttt{current-file-offset}\parallel\texttt{k2-AES-GCM-ciphertext}\right]$ 
				\item A keyfile comprised of $n$ `lines' of AES-GCM ciphertext.
				\end{itemize}
				The storage architecture was designed to achieve the following requirements: \vspace{-0.75em}
				\begin{enumerate}
				\setlength\itemsep{-0.3em}
				\item 	Can access files in a timely manner.
				\item 	Disk space is fully utilised.
				\item 	Files are laid out in a way which is easy to structurally navigate when consuming bits.
				\item 	Random bits can be securely deleted from the file system once used.
				\end{enumerate}
				These requirements are met due to the following design choices:\\
				\textbf{Requirement 1} is met by ext4 having no performance impediment for placing all the random bit files in one flat folder and accessing them directly through file name gained from the state file.\\
				\textbf{Requirement 2} is met by setting the file size of the random bit files to a multiple of the block file. If the random bit file was set at 100MB it would result in 3840 bytes being wasted on the disk.\\
				\textbf{Requirement 3} is met by ext4 allowing a theoretically limitless amount of files to be stored in the same simple to navigate flat folder.\\
				\textbf{Requirement 4} is met by disabling the journal in ext4, this is because the journal keeps data about file history which renders secure deletion useless. When disabled secure deletion again becomes possible.
			\subsection{Random bit file generation}
				The file generation process includes the following keys and structures:\\
				$\mathit{ks1}$ = \texttt{Intel RDRAND} keystream.\\
				$\mathit{ks2}$ = Primary \texttt{AES-CTR} keystream (regularly rekeyed).\\
				$\mathit{ks3}$ = Secondary \texttt{AES-CTR} keystream (single key).\\
				$\mathit{k1}$ = 128 bit \texttt{AES-GCM} key gained from scrypt.\\
				$\mathit{k2}$ = 128 bit \texttt{AES-GCM} key stored in state.\\
				$\mathit{keyfile}$ = File filled with `lines' of \texttt{AES-GCM} ciphertext which contain the seed keys for $\mathit{ks3}$.\vspace{1em}\\
				\textbf{Random bit file generation process:}
				\vspace{-0.75em}
				\begin{enumerate}
					\setlength\itemsep{-0.3em}
					\item Primary location of the random bit files is entered.
					\item Location to save the state file is entered.
					\item Simultaneous writing of multiple disks can be enabled.
					\item The amount of random bit files to be written is entered.
					\item Simple `progress.lock' file containing the last file to start being written to is generated to enable resuming of writing if the system is interrupted.
					\item State/pointer file is created/read, (depending if is resume or not).
					\item $\mathit{ks2}$ is seeded with \texttt{/dev/random} and Quantis (if available).
					\item $\mathit{ks3}$ is seeded with \texttt{/dev/random} and Quantis (if available) for encryption of the random bits.
					\item Seed for $\mathit{ks3}$ is encrypted by \texttt{AES-GCM} with (key=$\mathit{k2}$, nonce=file number) and saved into the $\mathit{keyfile}$.
					\item Random bits are generated by $\mathit{ks1} \oplus \mathit{ks2}$.
					\item $\mathit{ks2}$ is rekeyed at an interval which won't effect performance too badly.
					\item Random bits are then encrypted by $((\mathit{ks1} \oplus \mathit{ks2}) \oplus\mathit{ks3})$ and saved to disk.
					\item `progress.lock' file is deleted to denote that the files have been generated successfully.
				\end{enumerate}
			
				\tikzset{XOR/.style={draw,circle,append after command={
							[shorten >=\pgflinewidth, shorten <=\pgflinewidth,]
							(\tikzlastnode.north) edge (\tikzlastnode.south)
							(\tikzlastnode.east) edge (\tikzlastnode.west)
						}
					}
				}
				\begin{tikzpicture}
							\node[draw](devrandom) at ([yshift=1em]sources.south) {\texttt{/dev/random}};
							\node[draw](rdrand) at ([xshift=-8em]devrandom.west) {Intel \texttt{RDRAND}};
							\node[draw](quantis)  at ([xshift=9em]devrandom.east) {Quantis};
						\node[XOR, scale=2](sourcesXOR) at ([yshift=-3em]devrandom.south) {};
						%arrows from random and quantis to xor
						\draw [->, thick] (devrandom) to (sourcesXOR);
						\draw [->,thick] (quantis) to [out=270,in=0] (sourcesXOR);
						%aes ctr mode 
						\node[draw](ks2Generator) at ([yshift=-2em]sourcesXOR.south) {AES-CTR};
						%arrow from random and quantis xor to aes ctr
						\draw [->,thick] (sourcesXOR) to (ks2Generator);
						%final xor
						\node[XOR,scale=2](finalXOR) at ([yshift=-3em]ks2Generator.south) {};
						%arrow from AES-CTR generator to final keystream xor
						\draw [->,thick] (ks2Generator) to node [midway, label=right:$\mathit{ks2}$] {} (finalXOR);
						%arrow from rdrand to final keystream xor
						\draw [->,thick] (rdrand) to [out=270, in = 180] node [midway, label=right:$\mathit{ks1}$] {} (finalXOR);
						\node[XOR, scale=2](cryptoXOR) at ([yshift=-3em]finalXOR.south) {};
						%arrow from final keystream xor to crypto xor
						\draw [->,thick] (finalXOR) to node [midway, label=right:$\mathit{ksPtxt}$] {} (cryptoXOR);
						%save to file node
						\node[draw](finalFile) at ([yshift=-3em]cryptoXOR.south) {Output File};
						\draw [->,thick] (cryptoXOR) to node [midway, label=right:$\mathit{ksCtxt}$] {} (finalFile);
						
						%crypto stuff below quantis
						%key for AES CTR
						\node[XOR, scale=2](ks3srcXOR) at ([yshift=-4em]quantis.south) {};
						\draw [->,thick] (quantis) to (ks3srcXOR);
						\draw [->,thick] (devrandom) to [out=270] (ks3srcXOR);
						
						%ks3
						\node[draw](ks3CTR) at ([yshift=-3em]ks3srcXOR.south) {AES-CTR};
						\draw [->,thick] (ks3srcXOR) to (ks3CTR);
						\draw [->,thick] (ks3CTR) to [out=270, in=0] node [midway, label=right:$\mathit{ks3}$] {} (cryptoXOR);
						
						%ks3 key encryption
						\node[draw](aesGCM) at ([xshift=4em]ks3CTR.east) {AES-GCM};
						\draw [->,thick] (ks3srcXOR) to [out=0, in=90] node [midway, label=right:$\mathit{ks3}$ key] {} (aesGCM);
						\draw [->,thick] ([xshift=2.4em]aesGCM.east) to [out=0,in=0] node [midway, label=below:$\mathit{k2}$] {} (aesGCM);
						
						%keyfile
						\node[draw](keyFile) at ([yshift=-9em]aesGCM.south) {KeyFile};
						\draw [->,thick] (aesGCM) tonode [midway, label=right:key Ctxt] {} (keyFile);
						
				\end{tikzpicture}

			\subsection{Random bit file consumption}
				
		
		\section{Security Analysis}
%TODO	
		\section{Sample applications}
%TODO
			\subsection{WireGuard Integration}
%TODO
			\subsection{One time pad file encryption}
%TODO
		
						
\end{document}